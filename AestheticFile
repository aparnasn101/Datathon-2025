import streamlit as st
import pandas as pd
import numpy as np
import plotly.express as px
import matplotlib.pyplot as plt
import plotly.graph_objects as go
from sklearn.linear_model import LinearRegression
import calendar

st.set_page_config(page_title="Mai Shan Yun Data Analysis", layout="wide")


st.markdown(
    """
    <style>
      .stApp { 
          background-color: #f3e8ff;   /* light purple background */
          color: black;                /* default text color */
      }
      html, body, [class*="css"] {
          color: black !important;     /* force black text across all components */
      }
      h1, h2, h3, h4, h5, h6, p, div, span, label {
          color: black !important;
      }
    </style>
    """,
    unsafe_allow_html=True
)


st.title("Mai Shan Yun Data Analysis")

# ------------------------------
# 1) LOAD CSVs
# ------------------------------
orders = pd.read_csv("Restaurant Data.csv", thousands=',')
ingredients = pd.read_csv("IngredientsUsed.csv", thousands=',')
shipments = pd.read_csv("MSY Data - Shipment.csv")  # not used yet, but loaded

# Explicit month order
months_in_data = ["May", "June", "July", "August", "September", "October"]
orders["Month"] = pd.Categorical(orders["Month"], categories=months_in_data, ordered=True)

# ------------------------------
# 3) MERGE ORDERS WITH INGREDIENT RECIPES
#    (LEFT JOIN so October stays even if items don't match)
# ------------------------------
if "Item Name" not in orders.columns:
    st.error("Orders missing 'Item Name'. Columns: " + ", ".join(orders.columns))
if "Item Name" not in ingredients.columns:
    st.error("Ingredients missing 'Item Name'. Columns: " + ", ".join(ingredients.columns))

usage = orders.merge(ingredients, on="Item Name", how="left", indicator=True)

# Ingredient columns are everything from ingredients except the key
ingredient_cols = [c for c in ingredients.columns if c != "Item Name"]


# ------------------------------
# 5) BUILD INGREDIENT USAGE
# ------------------------------
# Coerce each ingredient column to numeric and multiply by dish count
for col in ingredient_cols:
    usage[col] = pd.to_numeric(usage[col], errors="coerce").fillna(0)
    usage[col] = usage[col] * usage["Count"]

# Monthly totals across all ingredients
monthly_totals = usage.groupby("Month", as_index=False)[ingredient_cols].sum()

# OPTIONAL: Drop columns that are all zeros across all months (keeps visuals cleaner)
drop_zero_only = True
if drop_zero_only:
    monthly_totals = monthly_totals.loc[:, (monthly_totals != 0).any(axis=0)]

# After dropping zero-only columns, recompute the list we will use everywhere
valid_cols = [c for c in ingredient_cols if c in monthly_totals.columns]

# ------------------------------
# 6) SHOW TABLE: INGREDIENTS USED PER MONTH
# ------------------------------
st.subheader("Ingredients Used per Month")
if len(valid_cols) == 0:
    st.warning("No ingredient columns with non-zero totals. Likely because many items (esp. October) use category names with no recipe match. Add recipes or a mapping for those items.")
else:
    st.dataframe(monthly_totals)

# ------------------------------
# 7) HEATMAP: ABSOLUTE USAGE
# ------------------------------
if len(valid_cols) > 0:
    heatmap_data = monthly_totals.set_index("Month")[valid_cols]
    fig = px.imshow(
        heatmap_data.T,
        labels=dict(x="Month", y="Ingredient", color="Usage"),
        title="Ingredient Usage Heatmap ðŸ”¥",
        aspect="auto"
    )
    st.plotly_chart(fig, use_container_width=True)

# ------------------------------
# 8) HEATMAP: PERCENT DISTRIBUTION ACROSS MONTHS
# ------------------------------
if len(valid_cols) > 0:
    ingredient_pct = monthly_totals.copy()
    # Avoid divide-by-zero: if a column sums to zero, keep it zero
    sums = ingredient_pct[valid_cols].sum(axis=0).replace({0: np.nan})
    ingredient_pct[valid_cols] = ingredient_pct[valid_cols].div(sums, axis=1) * 100
    ingredient_pct[valid_cols] = ingredient_pct[valid_cols].fillna(0)

    heatmap_pct = ingredient_pct.set_index("Month")[valid_cols]
    fig2 = px.imshow(
        heatmap_pct.T,
        labels=dict(x="Month", y="Ingredient", color="% of Total Usage"),
        title="Ingredient Usage Spread Across Months",
        aspect="auto",
        text_auto=True
    )
    st.plotly_chart(fig2, use_container_width=True)

# ------------------------------
# 9) SIMPLE LINEAR PROJECTIONS (NEXT 3 MONTHS)
# ------------------------------
st.subheader("Predicted Ingredient Usage for Next 3 Months")
if len(valid_cols) == 0:
    st.info("No valid ingredient columns to predict. Add recipe mappings for unmatched items to enable predictions.")
else:
    # Build a 3-row frame (future months) and fill each ingredient as a column
    future_index = ["Next Month 1", "Next Month 2", "Next Month 3"]  # 3 rows
    predictions = pd.DataFrame(index=future_index, columns=valid_cols, dtype=float)  # columns = ingredients

    # Use month index positions 0..N-1 for regression
    X = np.arange(len(monthly_totals)).reshape(-1, 1)

    for col in valid_cols:
        y = monthly_totals[col].values
        # If y is all zeros, the model is degenerate; keep zeros
        if np.allclose(y, 0):
            pred = np.array([0.0, 0.0, 0.0])
        else:
            model = LinearRegression()
            model.fit(X, y)
            X_future = np.arange(len(monthly_totals), len(monthly_totals) + 3).reshape(-1, 1)
            pred = np.round(model.predict(X_future), 1)
        predictions[col] = pred  # assign 3 values to the 3-row frame

    st.dataframe(predictions.T)  # rows = ingredients, cols = future months

##

# ----------------------------------------------------------
# TOP DISHES BAR CHART (single, corrected block)
# ----------------------------------------------------------
st.subheader("Top Dishes This Month")

# ensure numeric
orders["Count"] = pd.to_numeric(orders["Count"], errors="coerce").fillna(0)

# Create a clean "Sales Amount" from the CSV's "Amount"
if "Amount" in orders.columns:
    orders["Sales Amount"] = pd.to_numeric(orders["Amount"], errors="coerce").fillna(0.0)
else:
    orders["Sales Amount"] = 0.0

# months present in your orders, preserving calendar order
available_months = [m for m in months_in_data if "Month" in orders.columns and (orders["Month"] == m).any()]
default_idx = max(len(available_months) - 1, 0)

c1, c2, c3 = st.columns([1.1, 1, 1])
with c1:
    sel_month = st.radio("Select Month", options=available_months or months_in_data, index=default_idx)
with c2:
    metric_label = st.selectbox("Metric", ["Count", "Sales Amount"], index=0)
with c3:
    top_n = st.slider("Top N", min_value=5, max_value=20, value=10, step=1)

metric_col = "Count" if metric_label == "Count" else "Sales Amount"

month_df = orders.loc[orders["Month"] == sel_month, ["Item Name", "Count", "Sales Amount"]].copy()

if month_df.empty:
    st.info(f"No rows found for {sel_month}.")
else:
    agg = month_df.groupby("Item Name", as_index=False)[metric_col].sum()
    agg = agg.sort_values(metric_col, ascending=False).head(top_n).reset_index(drop=True)

    import textwrap
    agg["Label"] = agg["Item Name"].apply(lambda s: textwrap.fill(str(s), width=16))

    title_metric = "Orders" if metric_col == "Count" else "Sales Amount ($)"
    fig_top = px.bar(
        agg,
        x="Label",
        y=metric_col,
        text_auto=True,
        color_discrete_sequence=["#5bc0de"]
    )

    # Visibility: solid black text, centered/larger title, clear background
    fig_top.update_layout(
        title=dict(
            text=f"Top {len(agg)} Dishes in {sel_month} by {title_metric} ðŸ“Š",
            x=0.5, xanchor="center",
            font=dict(size=26, color="black")
        ),
        font=dict(color="black", size=14),
        xaxis_title="Dishes",
        yaxis_title=title_metric,
        xaxis_tickangle=-30,
        bargap=0.25,
        margin=dict(l=40, r=20, t=80, b=80),
        paper_bgcolor="white",
        plot_bgcolor="white",
    )
    fig_top.update_xaxes(
        tickfont=dict(color="black", size=12),
        title_font=dict(color="black", size=16),
        showline=True, linecolor="black",
        showgrid=True, gridcolor="lightgray"
    )
    fig_top.update_yaxes(
        tickfont=dict(color="black", size=12),
        title_font=dict(color="black", size=16),
        showline=True, linecolor="black",
        showgrid=True, gridcolor="lightgray",
        separatethousands=True
    )
    if metric_col == "Sales Amount":
        fig_top.update_yaxes(tickprefix="$")

    fig_top.update_traces(textfont=dict(color="black", size=13), textposition="outside", cliponaxis=False)

    st.plotly_chart(fig_top, use_container_width=True)




# ------------------------------
# 10) SIDEBAR: INGREDIENTS RUNNING LOW + DETAILED RESTOCK RECOMMENDATIONS
# ------------------------------
import datetime
st.sidebar.header("âš ï¸ Ingredients Running Low")

import datetime

st.sidebar.header("âš ï¸ Ingredients Running Low + Monthly Review")

# Timestamp of check
today = datetime.datetime.now()
st.sidebar.markdown(f"ðŸ“… **Status checked:** {today.strftime('%B %d, %Y')}")

# Dropdown to select month
selected_month = st.sidebar.selectbox("Select Month for Detailed Review", months_in_data)

# Get monthly usage for selected month
month_data = monthly_totals[monthly_totals["Month"] == selected_month]
if month_data.empty:
    st.sidebar.info(f"No data available for {selected_month}.")
else:
    st.sidebar.markdown(f"### ðŸ“¦ Monthly Review: {selected_month}")

    for ing in valid_cols:
        # Current percentage remaining vs max
        max_val = monthly_totals[ing].max()
        current_val = month_data[ing].iloc[0]
        pct = (current_val / max_val) * 100 if max_val > 0 else 0

        st.sidebar.markdown(f"#### ðŸ§‚ {ing}")
        match = shipments[shipments["ingredient"].str.lower().str.contains(ing.lower(), na=False)]

        if not match.empty:
            row = match.iloc[0]
            freq = str(row.get("frequency", "Unknown")).capitalize()
            qty = row.get("quantity_per_shipment", "Unknown")
            unit = row.get("unit_of_shipment", "")
            est_supply = row.get("estimated_weekly_supply", "Unknown")
            total_recv = row.get("total_received", "Unknown")

            # Timing notes for bullet points
            if pct <= 10:
                urgency = "ðŸš¨ Critically low â€“ immediate restock needed!"
                suggestion = "Contact supplier ASAP or pull from backup stock."
                week = "Final week of the month"
            elif pct <= 20:
                urgency = "âš ï¸ Low supply detected."
                suggestion = "Restock during the third week to avoid shortages."
                week = "Third week of the month"
            else:
                urgency = "âš ï¸ Below ideal threshold."
                suggestion = "Monitor daily and prepare restock order."
                week = "Second week of the month"

            if "biweek" in freq.lower():
                freq_note = "Delivered twice per month (every 2 weeks)."
            elif "week" in freq.lower():
                freq_note = "Delivered weekly."
            elif "month" in freq.lower():
                freq_note = "Delivered monthly."
            else:
                freq_note = "Delivery schedule not specified."

            # Display bullet points
            st.sidebar.markdown(f"""
            â€¢ **Status:** {urgency}  
            â€¢ **Frequency:** {freq_note}  
            â€¢ **Quantity per shipment:** {qty} {unit}  
            â€¢ **Total received per cycle:** {total_recv} {unit}  
            â€¢ **Estimated weekly supply:** {est_supply}  
            â€¢ **Stock level:** {pct:.1f}% of normal usage remaining  
            â€¢ **Suggested restock timing:** {week}  
            â€¢ **Action:** {suggestion}
            """)
        else:
            st.sidebar.markdown(f"""
            â€¢ No shipment data found for **{ing}**.  
            â€¢ Review manually and verify supplier frequency.  
            â€¢ Recommended: Add entry to `shipmentfile.csv` for tracking.
            """)

    st.sidebar.markdown("---")
    st.sidebar.caption("ðŸ”„ Data synced from shipmentfile.csv and monthly usage patterns.")


