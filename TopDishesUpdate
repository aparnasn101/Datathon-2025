import streamlit as st
import pandas as pd
import numpy as np
import plotly.express as px
import matplotlib.pyplot as plt
import plotly.graph_objects as go
from sklearn.linear_model import LinearRegression
import calendar

st.set_page_config(page_title="Mai Shan Yun Data Analysis", layout="wide")
st.title("Mai Shan Yun Data Analysis")

# ------------------------------
# 1) LOAD CSVs
# ------------------------------
orders = pd.read_csv("Restaurant Data.csv", thousands=',')
ingredients = pd.read_csv("IngredientsUsed.csv", thousands=',')
shipments = pd.read_csv("MSY Data - Shipment.csv")  # not used yet, but loaded

# Explicit month order
months_in_data = ["May", "June", "July", "August", "September", "October"]
orders["Month"] = pd.Categorical(orders["Month"], categories=months_in_data, ordered=True)

# ------------------------------
# 3) MERGE ORDERS WITH INGREDIENT RECIPES
#    (LEFT JOIN so October stays even if items don't match)
# ------------------------------
if "Item Name" not in orders.columns:
    st.error("Orders missing 'Item Name'. Columns: " + ", ".join(orders.columns))
if "Item Name" not in ingredients.columns:
    st.error("Ingredients missing 'Item Name'. Columns: " + ", ".join(ingredients.columns))

usage = orders.merge(ingredients, on="Item Name", how="left", indicator=True)

# Ingredient columns are everything from ingredients except the key
ingredient_cols = [c for c in ingredients.columns if c != "Item Name"]


# ------------------------------
# 5) BUILD INGREDIENT USAGE
# ------------------------------
# Coerce each ingredient column to numeric and multiply by dish count
for col in ingredient_cols:
    usage[col] = pd.to_numeric(usage[col], errors="coerce").fillna(0)
    usage[col] = usage[col] * usage["Count"]

# Monthly totals across all ingredients
monthly_totals = usage.groupby("Month", as_index=False)[ingredient_cols].sum()

# OPTIONAL: Drop columns that are all zeros across all months (keeps visuals cleaner)
drop_zero_only = True
if drop_zero_only:
    monthly_totals = monthly_totals.loc[:, (monthly_totals != 0).any(axis=0)]

# After dropping zero-only columns, recompute the list we will use everywhere
valid_cols = [c for c in ingredient_cols if c in monthly_totals.columns]

# ------------------------------
# 6) SHOW TABLE: INGREDIENTS USED PER MONTH
# ------------------------------
st.subheader("Ingredients Used per Month")
if len(valid_cols) == 0:
    st.warning("No ingredient columns with non-zero totals. Likely because many items (esp. October) use category names with no recipe match. Add recipes or a mapping for those items.")
else:
    st.dataframe(monthly_totals)

# ------------------------------
# 7) HEATMAP: ABSOLUTE USAGE
# ------------------------------
if len(valid_cols) > 0:
    heatmap_data = monthly_totals.set_index("Month")[valid_cols]
    fig = px.imshow(
        heatmap_data.T,
        labels=dict(x="Month", y="Ingredient", color="Usage"),
        title="Ingredient Usage Heatmap",
        aspect="auto"
    )
    st.plotly_chart(fig, use_container_width=True)

# ------------------------------
# 8) HEATMAP: PERCENT DISTRIBUTION ACROSS MONTHS
# ------------------------------
if len(valid_cols) > 0:
    ingredient_pct = monthly_totals.copy()
    # Avoid divide-by-zero: if a column sums to zero, keep it zero
    sums = ingredient_pct[valid_cols].sum(axis=0).replace({0: np.nan})
    ingredient_pct[valid_cols] = ingredient_pct[valid_cols].div(sums, axis=1) * 100
    ingredient_pct[valid_cols] = ingredient_pct[valid_cols].fillna(0)

    heatmap_pct = ingredient_pct.set_index("Month")[valid_cols]
    fig2 = px.imshow(
        heatmap_pct.T,
        labels=dict(x="Month", y="Ingredient", color="% of Total Usage"),
        title="Ingredient Usage Spread Across Months",
        aspect="auto",
        text_auto=True
    )
    st.plotly_chart(fig2, use_container_width=True)

# ------------------------------
# 9) SIMPLE LINEAR PROJECTIONS (NEXT 3 MONTHS)
# ------------------------------
st.subheader("Predicted Ingredient Usage for Next 3 Months")
if len(valid_cols) == 0:
    st.info("No valid ingredient columns to predict. Add recipe mappings for unmatched items to enable predictions.")
else:
    # Build a 3-row frame (future months) and fill each ingredient as a column
    future_index = ["Next Month 1", "Next Month 2", "Next Month 3"]  # 3 rows
    predictions = pd.DataFrame(index=future_index, columns=valid_cols, dtype=float)  # columns = ingredients

    # Use month index positions 0..N-1 for regression
    X = np.arange(len(monthly_totals)).reshape(-1, 1)

    for col in valid_cols:
        y = monthly_totals[col].values
        # If y is all zeros, the model is degenerate; keep zeros
        if np.allclose(y, 0):
            pred = np.array([0.0, 0.0, 0.0])
        else:
            model = LinearRegression()
            model.fit(X, y)
            X_future = np.arange(len(monthly_totals), len(monthly_totals) + 3).reshape(-1, 1)
            pred = np.round(model.predict(X_future), 1)
        predictions[col] = pred  # assign 3 values to the 3-row frame

    st.dataframe(predictions.T)  # rows = ingredients, cols = future months

##

# ----------------------------------------------------------
# TOP DISHES BAR CHART (clean formatting + flexible controls)
# ----------------------------------------------------------
import textwrap

st.subheader("Top Dishes This Month")

# make sure numeric
orders["Count"] = pd.to_numeric(orders["Count"], errors="coerce").fillna(0)
if "Amount" in orders.columns:
    orders["Amount"] = pd.to_numeric(orders["Amount"], errors="coerce").fillna(0)
else:
    orders["Amount"] = 0.0

# months present in your orders, preserving your calendar order
available_months = [m for m in months_in_data if (orders["Month"] == m).any()]
default_idx = max(len(available_months) - 1, 0)  # default to latest available

c1, c2, c3 = st.columns([1.1, 1, 1])
with c1:
    sel_month = st.radio("Select Month", options=available_months or months_in_data, index=default_idx)
with c2:
    metric = st.selectbox("Metric", ["Count", "Amount"], index=0)
with c3:
    top_n = st.slider("Top N", min_value=5, max_value=20, value=10, step=1)

month_df = orders.loc[orders["Month"] == sel_month, ["Item Name", "Count", "Amount"]].copy()

if month_df.empty:
    st.info(f"No rows found for {sel_month}.")
else:
    # aggregate, sort, take top N
    agg = month_df.groupby("Item Name", as_index=False)[metric].sum()
    agg = agg.sort_values(metric, ascending=False).head(top_n).reset_index(drop=True)

    # wrap long labels so they donâ€™t collide
    agg["Label"] = agg["Item Name"].apply(lambda s: textwrap.fill(str(s), width=16))

    title_metric = "Orders" if metric == "Count" else "Sales ($)"
    fig_top = px.bar(
        agg,
        x="Label",
        y=metric,
        text_auto=True,
        title=f"Top {len(agg)} Dishes in {sel_month} by {title_metric}",
        color_discrete_sequence=["#5bc0de"]
    )
    fig_top.update_layout(
        xaxis_title="Dishes",
        yaxis_title=title_metric,
        xaxis_tickangle=-30,
        title_x=0.5,
        bargap=0.25,
        margin=dict(l=40, r=20, t=60, b=80),
        plot_bgcolor="white",
    )
    # show values outside bars; allow labels beyond axes
    fig_top.update_traces(textposition="outside", cliponaxis=False)
    # nicer y-axis
    fig_top.update_yaxes(separatethousands=True, showgrid=True, gridcolor="rgba(0,0,0,0.1)")

    st.plotly_chart(fig_top, use_container_width=True)
